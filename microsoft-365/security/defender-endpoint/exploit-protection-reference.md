---
title: Référence Exploit Protection
keywords: atténuations, vulnérabilités, vulnérabilité, atténuation, exploit, attaques, emet
description: Détails sur le fonctionnement de la fonctionnalité Exploit Protection dans Windows 10
search.product: eADQiWindows 10XVcnh
ms.pagetype: security
ms.prod: m365-security
ms.mktglfcycl: manage
ms.sitesec: library
localization_priority: Normal
audience: ITPro
author: denisebmsft
ms.author: deniseb
ms.date: 01/06/2021
ms.reviewer: cjacks
manager: dansimp
ms.custom: asr
ms.technology: mde
ms.openlocfilehash: b224b32e26435e2612ec00c8c4544b4c3cff4344
ms.sourcegitcommit: 956176ed7c8b8427fdc655abcd1709d86da9447e
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 03/23/2021
ms.locfileid: "51064190"
---
# <a name="exploit-protection-reference"></a>Exploit Protection Reference

[!INCLUDE [Microsoft 365 Defender rebranding](../../includes/microsoft-defender.md)]


**S’applique à :**
- [Microsoft Defender pour point de terminaison](https://go.microsoft.com/fwlink/?linkid=2154037)
- [Microsoft 365 Defender](https://go.microsoft.com/fwlink/?linkid=2118804)

>Vous souhaitez découvrir Microsoft Defender pour le point de terminaison ? [Inscrivez-vous à un essai gratuit.](https://www.microsoft.com/microsoft-365/windows/microsoft-defender-atp?ocid=docs-wdatp-enablesiem-abovefoldlink)

Exploit Protection fournit des protections avancées pour les applications que le professionnel de l’informatique peut appliquer une fois que le développeur a compilé et distribué le logiciel.

Cet article vous aide à comprendre le fonctionnement d’Exploit Protection, tant au niveau de la stratégie qu’au niveau de l’atténuation individuelle, pour vous aider à créer et appliquer correctement des stratégies Exploit Protection.

## <a name="how-mitigations-are-applied"></a>Application des atténuations

Les atténuations Exploit Protection sont appliquées par application.

Les atténuations sont configurées via une entrée de Registre pour chaque programme pour qui vous configurez des protections. Ces paramètres sont stockés dans l’entrée de Registre **MitigationOptions** pour chaque programme (**HKEY_LOCAL_MACHINE \ SOFTWARE \ Microsoft \ Windows NT \ CurrentVersion \ Image File Execution Options \ *ImageFileName* \ MitigationOptions**). Elles prennent effet lorsque vous redémarrez le programme et restent effectives jusqu’à ce que vous les modifiez et redémarrez le programme à nouveau.

> [!IMPORTANT]
> Les options d’exécution de fichier image vous permettent uniquement de spécifier un nom de fichier ou un chemin d’accès, et non un numéro de version, une architecture ou tout autre différenciateur. Faites attention à cibler les atténuations sur les applications qui ont des noms ou des chemins d’accès uniques, en les appliquant uniquement sur les appareils sur lesquels vous avez testé cette version et cette architecture de l’application.

Si vous configurez des atténuations Exploit Protection à l’aide d’un fichier de configuration XML, via PowerShell, une stratégie de groupe ou la gestion des stratégies de groupe, lors du traitement de ce fichier de configuration XML, des paramètres de Registre individuels seront configurés pour vous.

Lorsque la stratégie de distribution du fichier XML n’est plus appliquée, les paramètres déployés par ce fichier de configuration XML ne sont pas automatiquement supprimés. Pour supprimer les paramètres Exploit Protection, exportez la configuration XML à partir d’un nouvel appareil Windows 10 et déployez ce nouveau fichier XML. Microsoft fournit également un fichier XML dans le cadre des lignes de base de sécurité Windows pour la réinitialisation des paramètres Exploit Protection.

Pour réinitialiser les paramètres Exploit Protection à l’aide de PowerShell, vous pouvez utiliser la commande suivante :

```powershell
Set-ProcessMitigation -PolicyFilePath EP-reset.xml
```
Voici les EP-reset.xml distribués avec les lignes de base de sécurité Windows :
```xml
<?xml version="1.0" encoding="UTF-8"?>
<MitigationPolicy>
  <AppConfig Executable="ONEDRIVE.EXE">
    <DEP OverrideDEP="false" />
    <ASLR OverrideRelocateImages="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
    <ImageLoad OverrideBlockRemoteImages="false" />
  </AppConfig>
  <AppConfig Executable="firefox.exe">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
  </AppConfig>
  <AppConfig Executable="fltldr.exe">
    <DEP OverrideDEP="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
    <ImageLoad OverrideBlockRemoteImages="false" />
    <ChildProcess OverrideChildProcess="false" />
  </AppConfig>
  <AppConfig Executable="GROOVE.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
    <ImageLoad OverrideBlockRemoteImages="false" />
    <ChildProcess OverrideChildProcess="false" />
  </AppConfig>
  <AppConfig Executable="Acrobat.exe">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="AcroRd32.exe">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="chrome.exe">
    <DEP OverrideDEP="false" />
  </AppConfig>
  <AppConfig Executable="EXCEL.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="iexplore.exe">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="INFOPATH.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="java.exe">
    <DEP OverrideDEP="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="javaw.exe">
    <DEP OverrideDEP="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="javaws.exe">
    <DEP OverrideDEP="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="LYNC.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="MSACCESS.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="MSPUB.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="OIS.EXE">
    <DEP OverrideDEP="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="OUTLOOK.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="plugin-container.exe">
    <DEP OverrideDEP="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="POWERPNT.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="PPTVIEW.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="VISIO.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="VPREVIEW.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="WINWORD.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="wmplayer.exe">
    <DEP OverrideDEP="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="wordpad.exe">
    <DEP OverrideDEP="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
</MitigationPolicy>
```

## <a name="mitigation-reference"></a>Référence de l’atténuation

Les sections suivantes détaillent les protections fournies par chaque atténuation Exploit Protection, les considérations de compatibilité pour l’atténuation et les options de configuration disponibles.

## <a name="arbitrary-code-guard"></a>Protection de code arbitraire

### <a name="description"></a>Description

La protection de code arbitraire permet de se protéger contre le chargement du code de son choix dans la mémoire par une vulnérabilité de sécurité de mémoire et la possibilité d’exécuter ce code.

La protection du code arbitraire protège une application contre l’exécution de code généré dynamiquement (code qui n’est pas chargé, par exemple, à partir de l’exe lui-même ou d’une dll). La protection de code arbitraire fonctionne en empêchant la mémoire d’être marquée comme exécutable. Lorsqu’une application tente [d’allouer de la mémoire,](https://docs.microsoft.com/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc)nous vérifions les indicateurs de protection. (La mémoire peut être allouée avec des indicateurs de protection de lecture, d’écriture et/ou d’exécution.) Si l’allocation tente d’inclure l’indicateur de [*protection*](https://docs.microsoft.com/windows/win32/memory/memory-protection-constants) d’exécution, l’allocation de mémoire échoue et renvoie un code d’erreur (STATUS_DYNAMIC_CODE_BLOCKED). De même, si une application tente de modifier les indicateurs de [protection](https://docs.microsoft.com/windows/win32/api/memoryapi/nf-memoryapi-virtualprotect) de la mémoire qui ont déjà été alloués et inclut l’indicateur de [*protection*](https://docs.microsoft.com/windows/win32/memory/memory-protection-constants) exécuter, la modification d’autorisation échoue et renvoie un code d’erreur (STATUS_DYNAMIC_CODE_BLOCKED).

En empêchant  la mise en place de l’indicateur d’exécution, la fonctionnalité de prévention de l’exécution des données de Windows 10 peut ensuite se protéger contre la mise en mémoire du pointeur d’instructions et l’exécution de ce code.

### <a name="compatibility-considerations"></a>Considérations sur la compatibilité

La protection de code arbitraire empêche l’allocation de mémoire comme exécutable, ce qui présente un problème de compatibilité avec les approches telles que les compilateurs juste-à-temps (JIT). La plupart des navigateurs modernes, par exemple, compilent JavaScript en code natif afin d’optimiser les performances. Pour prendre en charge cette atténuation, ils devront être réarmés pour déplacer la compilation JIT en dehors du processus protégé. Les autres applications dont la conception génère dynamiquement du code à partir de scripts ou d’autres langages intermédiaires seront incompatibles avec cette atténuation.

### <a name="configuration-options"></a>Options de configuration

**Autoriser le retrait du** thread : vous pouvez configurer l’atténuation pour autoriser un thread individuel à refuser cette protection. Le développeur doit avoir écrit l’application avec connaissance de cette atténuation et avoir appelé l’API [**SetThreadInformation**](https://docs.microsoft.com/windows/win32/api/processthreadsapi/nf-processthreadsapi-setthreadinformation) avec le paramètre *ThreadInformation* paramétré sur **ThreadDynamicCodePolicy** afin d’être autorisé à exécuter du code dynamique sur ce thread.

**Audit uniquement** : vous pouvez activer cette atténuation en mode audit afin de mesurer l’impact potentiel de la compatibilité sur une application. Les événements d’audit peuvent ensuite être visualisateurs dans l’observateur d’événements ou à l’aide de la recherche avancée dans [Defender for Endpoint](https://docs.microsoft.com/microsoft-365/security/defender/advanced-hunting-overview).

## <a name="block-low-integrity-images"></a>Bloquer les images à faible intégrité

### <a name="description"></a>Description

Bloquer les images à faible intégrité empêche l’application de charger des fichiers non sécurisés, généralement parce qu’ils ont été téléchargés à partir d’Internet à partir d’un navigateur en bac à sable.

Cette atténuation bloque le chargement de l’image si l’image possède une entrée de contrôle d’accès (ACE) qui accorde l’accès aux processus à faible il et qui n’a pas d’étiquette de confiance ACE. Il est implémenté par le gestionnaire de mémoire, ce qui empêche le fichier d’être mappé dans la mémoire. Si une application tente de ma cartographier une image à faible intégrité, elle déclenche une STATUS_ACCESS_DENIED d’erreur. Pour plus d’informations sur le fonctionnement des niveaux d’intégrité, voir [Contrôle d’intégrité obligatoire.](https://docs.microsoft.com/windows/win32/secauthz/mandatory-integrity-control)

### <a name="compatibility-considerations"></a>Considérations sur la compatibilité

Bloquer les images à faible intégrité empêche l’application de charger les fichiers téléchargés à partir d’Internet. Si votre flux de travail d’application nécessite le chargement d’images téléchargées, vous devez vous assurer qu’elles sont téléchargées à partir d’un processus de confiance supérieure ou qu’elles sont explicitement réétiquetés afin d’appliquer cette atténuation.

### <a name="configuration-options"></a>Options de configuration

**Audit uniquement** : vous pouvez activer cette atténuation en mode audit afin de mesurer l’impact potentiel de la compatibilité sur une application. Les événements d’audit peuvent ensuite être visualisateurs dans l’observateur d’événements ou à l’aide de la recherche avancée [dans Microsoft Defender pour point de terminaison.](https://docs.microsoft.com/microsoft-365/security/defender/advanced-hunting-overview)

## <a name="block-remote-images"></a>Bloquer les images distantes

### <a name="description"></a>Description

Le blocage d’images distantes permet d’empêcher l’application de charger des fichiers hébergés sur un appareil distant, tel qu’un partage UNC. Le blocage des images distantes permet de se protéger contre le chargement de binaires en mémoire sur un appareil externe contrôlé par l’attaquant.

Cette atténuation bloque les chargements d’image si l’image est déterminée comme se trouve sur un appareil distant. Il est implémenté par le gestionnaire de mémoire, ce qui empêche le fichier d’être mappé dans la mémoire. Si une application tente de ma cartographier un fichier distant, elle déclenche STATUS_ACCESS_DENIED erreur.

### <a name="compatibility-considerations"></a>Considérations sur la compatibilité

Bloquer les images distantes empêche l’application de charger des images à partir d’appareils distants. Si votre application charge des fichiers ou des plug-ins à partir d’appareils distants, elle ne sera pas compatible avec cette atténuation.

### <a name="configuration-options"></a>Options de configuration

**Audit uniquement** : vous pouvez activer cette atténuation en mode audit afin de mesurer l’impact potentiel de la compatibilité sur une application. Les événements d’audit peuvent ensuite être visualisateurs dans l’observateur d’événements ou à l’aide de la recherche avancée [dans Microsoft Defender pour point de terminaison.](https://docs.microsoft.com/microsoft-365/security/defender/advanced-hunting-overview)

## <a name="block-untrusted-fonts"></a>Bloquer les polices nontrues

### <a name="description"></a>Description

Bloquer les polices nontrues atténue le risque d’une faille dans l’évaluation des polices, ce qui permet à l’attaquant d’exécuter du code sur l’appareil. Seules les polices installées dans le répertoire windows\fonts sont chargées pour être traitées par LDI.

Cette atténuation est implémentée dans LDI, qui valide l’emplacement du fichier. Si le fichier ne se trouve pas dans le répertoire des polices système, la police n’est pas chargée pour l’examen et cet appel échoue.

Cette atténuation s’ajoute à l’atténuation intégrée fournie dans Windows 10 1607 et les ultérieures, qui déplace l’utilisation des polices en dehors du noyau et dans un conteneur d’application en mode utilisateur. Toute exploitation basée sur l’évaluation des polices, par conséquent, se produit dans un contexte en bac à sable et isolé, ce qui réduit considérablement le risque. Pour plus d’informations sur cette atténuation, consultez le blog [Renforcement de Windows 10 avec les préventions d’attaques « zero-day](https://www.microsoft.com/security/blog/2017/01/13/hardening-windows-10-with-zero-day-exploit-mitigations/)».

### <a name="compatibility-considerations"></a>Considérations sur la compatibilité

L’utilisation la plus courante des polices en dehors du répertoire des polices système est avec les [polices web.](https://docs.microsoft.com/typography/fonts/font-faq#web) Les navigateurs modernes, tels que Microsoft Edge, utilisent DirectWrite au lieu de GDI et ne sont pas touchés. Toutefois, les navigateurs hérités, tels qu’Internet Explorer 11 (et le mode IE dans le nouveau Microsoft Edge) peuvent être touchés, en particulier avec les applications telles qu’Office 365, qui utilisent des glyphes de police pour afficher l’interface utilisateur.

### <a name="configuration-options"></a>Options de configuration

**Audit uniquement** : vous pouvez activer cette atténuation en mode audit afin de mesurer l’impact potentiel de la compatibilité sur une application. Les événements d’audit peuvent ensuite être visualisateurs dans l’observateur d’événements ou à l’aide de la recherche avancée [dans Microsoft Defender pour point de terminaison.](https://docs.microsoft.com/microsoft-365/security/defender/advanced-hunting-overview)

## <a name="code-integrity-guard"></a>Protection de l’intégrité du code

### <a name="description"></a>Description

La protection de l’intégrité du code garantit que tous les binaires chargés dans un processus sont signés numériquement par Microsoft. La protection de l’intégrité du code inclut des signatures [WHQL](https://docs.microsoft.com/windows-hardware/drivers/install/whql-release-signature) (Windows Hardware Quality Labs), ce qui permet aux pilotes approuvés par WHQL de s’exécuter dans le processus.

Cette atténuation est implémentée dans le gestionnaire de mémoire, ce qui empêche le fichier binaire d’être mappé dans la mémoire. Si vous tentez de charger un fichier binaire qui n’est pas signé par Microsoft, le gestionnaire de mémoire retourne l’erreur STATUS_INVALID_IMAGE_HASH. En bloquant au niveau du gestionnaire de mémoire, cela empêche à la fois les binaires chargés par le processus et les binaires injectés dans le processus.

### <a name="compatibility-considerations"></a>Considérations sur la compatibilité

Cette atténuation bloque spécifiquement tout fichier binaire qui n’est pas signé par Microsoft. En tant que tel, il sera incompatible avec la plupart des logiciels tiers, sauf si ce logiciel est distribué par le Microsoft Store (et signé numériquement) et que l’option permettant d’autoriser le chargement des images signées par le Microsoft Store est sélectionnée.

### <a name="configuration-options"></a>Options de configuration

Autorisez également le chargement des images signées par le Microsoft Store : les applications distribuées par le Microsoft Store seront signées numériquement par le Microsoft Store, et l’ajout de cette configuration permettra au chargement par l’application des binaires qui ont passé par le processus de certification du Microsoft **Store.**

**Audit uniquement** : vous pouvez activer cette atténuation en mode audit afin de mesurer l’impact potentiel de la compatibilité sur une application. Les événements d’audit peuvent ensuite être visualisateurs dans l’observateur d’événements ou à l’aide de la recherche avancée [dans Microsoft Defender pour point de terminaison.](https://docs.microsoft.com/microsoft-365/security/defender/advanced-hunting-overview)

## <a name="control-flow-guard-cfg"></a>Protection du flux de contrôle (CFG)

### <a name="description"></a>Description

La protection du flux de contrôle (CFG) atténue le risque d’attaques utilisant des vulnérabilités de corruption de mémoire en protégeant les appels de fonction indirects. Par exemple, une personne malveillante peut avoir une vulnérabilité de dépassement de mémoire tampon pour remplacer la mémoire contenant un pointeur de fonction et remplacer ce pointeur de fonction par un pointeur vers le code exécutable de son choix (qui a peut-être également été injecté dans le programme).

Cette atténuation est fournie par injection d’une autre vérification au moment de la compilation. Avant chaque appel de fonction indirecte, une autre instruction est ajoutée pour vérifier que la cible est une cible d’appel valide avant d’être appelée. Si la cible n’est pas une cible d’appel valide, l’application est terminée. De ce fait, seules les applications compilées avec la prise en charge CFG peuvent bénéficier de cette atténuation.

La vérification d’une cible valide est fournie par le noyau Windows. Lorsque des fichiers exécutables sont chargés, les métadonnées des cibles d’appels indirects sont extraites au moment du chargement et marquées comme cibles d’appels valides. En outre, lorsque la mémoire est allouée et marquée comme exécutable (par exemple pour le code généré), ces emplacements de mémoire sont également marqués comme cibles d’appel valides, pour prendre en charge des mécanismes tels que la compilation JIT.

### <a name="compatibility-considerations"></a>Considérations sur la compatibilité

Étant donné que les applications doivent être compilées pour prendre en charge CFG, elles déclarent implicitement leur compatibilité avec elle. Par conséquent, la plupart des applications doivent fonctionner avec cette atténuation activée. Étant donné que ces vérifications sont compilées dans le fichier binaire, la configuration que vous pouvez appliquer consiste simplement à désactiver les vérifications dans le noyau Windows. En d’autres termes, l’atténuation est mise en place par défaut, mais vous pouvez configurer le noyau Windows pour qu’il retourne toujours « oui » si vous déterminez ultérieurement qu’il existe un problème de compatibilité que le développeur d’applications n’a pas découvert dans ses tests, ce qui devrait être rare.

### <a name="configuration-options"></a>Options de configuration

Utiliser la loi **CFG** stricte : en mode strict, tous les binaires chargés dans le processus doivent être compilés pour Control Flow Guard (ou n’ont pas de code exécutable dans ces derniers, tels que les DLL de ressources) pour pouvoir être chargés.

> [!Note]
> **La protection du flux de contrôle** n’a pas de mode audit. Les binaires sont compilés avec cette atténuation activée.

## <a name="data-execution-prevention-dep"></a>Prévention de l’exécution des données

### <a name="description"></a>Description

La prévention de l’exécution des données empêche l’exécution de la mémoire qui n’a pas été explicitement allouée comme exécutable. DeP permet de se protéger contre l’injection de code malveillant dans le processus, par exemple via un dépassement de mémoire tampon, puis l’exécution de ce code.

Si vous tentez de définir le pointeur d’instruction sur une adresse mémoire non marquée comme exécutable, le processeur va créer une exception (violation de la protection générale), ce qui entraîne le crash de l’application.

### <a name="compatibility-considerations"></a>Considérations sur la compatibilité

Tous les exécutables x64, ARM et ARM-64 sont activés par défaut et ne peuvent pas être désactivés. Étant donné qu’une application n’a jamais été exécutée sans la PED, la compatibilité est supposée.

La PED est activée par défaut pour tous les binaires x86 (32 bits), mais la PED peut être désactivée par processus. Certaines anciennes applications héritées, généralement développées avant Windows XP SP2, peuvent ne pas être compatibles avec DEP. Ces applications génèrent généralement du code dynamiquement (par exemple, la compilation JIT) ou des liens vers des bibliothèques plus anciennes (telles que des versions antérieures d’ATL) qui génèrent du code de manière dynamique.

### <a name="configuration-options"></a>Options de configuration

**Activer l’émulation de thunk ATL** : cette option de configuration désactive l’émulation de thunk ATL. ATL, la bibliothèque ActiveX modèles, est conçue pour être aussi petite et rapide que possible. Pour réduire la taille des binaires, il utilise une technique appelée *« thunking*». Le thunking est généralement pensé pour l’interaction entre les applications 32 bits et 16 bits, mais il n’existe aucun composant 16 bits à ATL ici. Au lieu de cela, pour optimiser la taille binaire, ATL stocke le code de l’ordinateur en mémoire qui n’est pas aligné sur le mot (création d’un fichier binaire plus petit), puis appelle ce code directement. Les composants ATL compilés avec Visual Studio 7.1 ou une antérieure (Visual Studio 2003) n’allouent pas cette mémoire comme exécutable : l’émulation de thunk résout ce problème de compatibilité. Les applications qui ont un modèle d’extension binaire (par exemple, Internet Explorer 11) doivent souvent activer l’émulation de thunk ATL.

## <a name="disable-extension-points"></a>Désactiver les points d’extension

### <a name="description"></a>Description

Cette atténuation désactive divers points d’extension pour une application, qui peuvent être utilisés pour établir la persistance ou élever les privilèges de contenu malveillant.

Cela inclut les opérations suivantes :

- **DLL AppInit** : chaque fois qu’un processus démarre, le système charge la DLL spécifiée dans le contexte du processus nouvellement démarré avant d’appeler sa fonction de point d’entrée. [Vous pouvez trouver des détails sur les DLL AppInit ici.](https://docs.microsoft.com/windows/win32/winmsg/about-window-classes#application-global-classes) Avec cette atténuation appliquée, les DLL AppInit ne sont pas chargées. À partir de Windows 7, les DLL AppInit doivent être signées numériquement, [comme décrit ici.](https://docs.microsoft.com/windows/win32/win7appqual/appinit-dlls-in-windows-7-and-windows-server-2008-r2) En outre, à partir de Windows 8, les DLL AppInit ne seront pas chargées si SecureBoot est activé, comme décrit [ici.](https://docs.microsoft.com/windows/win32/dlls/secure-boot-and-appinit-dlls)
- **IME hérité :** un éditeur de méthode d’entrée (IME) permet à un utilisateur de taper du texte dans une langue qui possède plus de caractères que ce qui peut être représenté sur un clavier. Les tiers peuvent créer des IMU. Un IME malveillant peut obtenir des informations d’identification ou d’autres informations sensibles à partir de cette capture d’entrée. Certains IMU, appelés IME hérités, fonctionnent uniquement sur les applications de bureau Windows, et non sur les applications UWP. Cette atténuation empêche également cet IME hérité de se charger dans l’application de bureau Windows spécifiée.
- **Hooks d’événements Windows** : une application peut appeler [l’API SetWinEventHook](https://docs.microsoft.com/windows/win32/api/winuser/nf-winuser-setwineventhook) pour inscrire l’intérêt d’un événement en cours. Une DLL est spécifiée et peut être injectée dans le processus. Cette atténuation force la mise en ligne du hook dans le processus d’inscription plutôt que l’exécution in-process via une DLL injectée.

### <a name="compatibility-considerations"></a>Considérations sur la compatibilité

La plupart de ces points d’extension sont peu utilisés, donc l’impact sur la compatibilité est généralement faible, en particulier au niveau d’une application individuelle. La seule considération est si les utilisateurs utilisent des IED hérités tiers qui ne fonctionnent pas avec l’application protégée.

### <a name="configuration-options"></a>Options de configuration

Il n’existe aucune option de configuration pour cette atténuation.

> [!Note]
> **Désactiver les points d’extension** n’a pas de mode audit.

## <a name="disable-win32k-system-calls"></a>Désactiver les appels système Win32k

### <a name="description"></a>Description

Win32k.sys fournit une large surface d’attaque pour un attaquant. En tant que composant en mode noyau, il est souvent ciblé en tant que vecteur d’échappatoire pour les applications en bac à sable (sandbox). Cette atténuation empêche les appels dans win32k.sys en bloquant un thread de se convertir lui-même en thread d’interface graphique graphique, qui est ensuite autorisé à appeler les fonctions Win32k. Un thread n’est pas une interface utilisateur graphique lorsqu’il est créé, mais converti lors du premier appel win32k.sys, ou via un appel d’API [à IsGuiThread](https://docs.microsoft.com/windows/win32/api/winuser/nf-winuser-isguithread).

### <a name="compatibility-considerations"></a>Considérations sur la compatibilité

Cette atténuation est conçue pour les processus dédiés qui ne sont pas des processus d’interface utilisateur. Par exemple, de nombreux navigateurs modernes utilisent l’isolation des processus et intègrent des processus autres que des processus d’interface utilisateur. Toute application qui affiche une interface graphique graphique à l’aide d’un seul processus sera impactée par cette atténuation.

### <a name="configuration-options"></a>Options de configuration

**Audit uniquement** : vous pouvez activer cette atténuation en mode audit afin de mesurer l’impact potentiel de la compatibilité sur une application. Les événements d’audit peuvent ensuite être visualisateurs dans l’observateur d’événements ou à l’aide de la recherche avancée [dans Microsoft Defender pour point de terminaison.](https://docs.microsoft.com/microsoft-365/security/defender/advanced-hunting-overview)

## <a name="do-not-allow-child-processes"></a>Ne pas autoriser les processus enfants

### <a name="description"></a>Description

Cette atténuation empêche une application de créer de nouvelles applications enfants. Une technique courante utilisée par les adversaires consiste à lancer un processus approuvé sur l’appareil avec des entrées malveillantes (une attaque « de la terre », qui nécessite souvent le lancement d’une autre application sur l’appareil). S’il n’existe aucune raison légitime pour laquelle une application lancerait un processus enfant, cette atténuation atténue ce vecteur d’attaque potentiel. L’atténuation est appliquée en attnuant une propriété sur le jeton de processus, ce qui bloque la création d’un jeton pour le processus enfant avec le message d’erreur STATUS_CHILD_PROCESS_BLOCKED.

### <a name="compatibility-considerations"></a>Considérations sur la compatibilité

Si votre application lance des applications enfants pour une raison quelconque, telles que la prise en charge des liens hypertexte qui lancent un navigateur ou un navigateur externe, ou qui lancent d’autres utilitaires sur l’ordinateur, cette fonctionnalité sera rompue avec cette atténuation appliquée.

### <a name="configuration-options"></a>Options de configuration

**Audit uniquement** : vous pouvez activer cette atténuation en mode audit afin de mesurer l’impact potentiel de la compatibilité sur une application. Les événements d’audit peuvent ensuite être visualisateurs dans l’observateur d’événements ou à l’aide de la recherche avancée [dans Microsoft Defender pour point de terminaison.](https://docs.microsoft.com/microsoft-365/security/defender/advanced-hunting-overview)

## <a name="export-address-filtering"></a>Exporter le filtrage des adresses

### <a name="description"></a>Description

Le filtrage d’adresses d’exportation (EAF) atténue le risque que du code malveillant recherche la table d’adresses d’exportation de tous les modules chargés pour rechercher des modules qui contiennent des API utiles pour leur attaque. Il s’agit d’une tactique courante utilisée par shellcode. Afin d’atténuer le risque d’une telle attaque, cette atténuation protège trois modules fréquemment exposés :

- ntdll.dll
- kernelbase.dll
- kernel32.dll

L’atténuation protège la page mémoire dans le [répertoire d’exportation qui pointe vers la [table d’adresses d’exportation.](https://docs.microsoft.com/windows/win32/debug/pe-format#export-address-table) La protection contre PAGE_GUARD [mémoire](https://docs.microsoft.com/windows/win32/memory/creating-guard-pages) est appliquée à cette page mémoire. Lorsqu’une personne tente d’accéder à cette mémoire, elle génère une STATUS_GUARD_PAGE_VIOLATION. L’atténuation gère cette exception et si l’instruction d’accès n’est pas validée, le processus est interrompu.

### <a name="compatibility-considerations"></a>Considérations sur la compatibilité

Cette atténuation est principalement un problème pour les applications telles que les déboguers, les applications en bac à sable( sandbox), les applications utilisant la gestion des données numériques (DRM) ou les applications qui implémentent la technologie anti-débogage.

### <a name="configuration-options"></a>Options de configuration

**Validez l’accès** aux modules qui sont couramment exploités par des attaques : cette option, également appelée EAF+, ajoute des protections pour les autres modules fréquemment attaquants :

- `mshtml.dll`
- `flash*.ocx`
- `jscript*.ocx`
- `vbscript.dll`
- `vgx.dll`
- `mozjs.dll`
- `xul.dll`
- `acrord32.dll`
- `acrofx32.dll`
- `acroform.api`

En outre, en activant EAF+, cette atténuation ajoute la protection PAGE_GUARD à la page contenant l’en-tête « MZ », les deux premiers octets de l’en-tête DOS dans un fichier [PE,](https://docs.microsoft.com/windows/win32/debug/pe-format#ms-dos-stub-image-only)qui est un autre aspect du contenu mémoire connu que le shellcode peut rechercher pour identifier les modules potentiellement susceptibles d’intéresser la mémoire.

**Audit uniquement** : vous pouvez activer cette atténuation en mode audit afin de mesurer l’impact potentiel de la compatibilité sur une application. Les événements d’audit peuvent ensuite être visualisateurs dans l’observateur d’événements ou à l’aide de la recherche avancée [dans Microsoft Defender pour point de terminaison.](https://docs.microsoft.com/microsoft-365/security/defender/advanced-hunting-overview)

## <a name="force-randomization-for-images-mandatory-aslr"></a>Forcer la randomisation pour les images (ASLR obligatoire)

### <a name="description"></a>Description

La randomisation du schéma d’espace d’adressamage (ASLR) atténue le risque qu’une personne malveillante utilise sa connaissance de la disposition de la mémoire du système afin d’exécuter du code déjà présent dans la mémoire du processus et déjà marqué comme exécutable. Cela peut atténuer le risque qu’une personne malveillante utilise des techniques telles que les attaques de retour à la base de données, où l’adversaire définit le contexte, puis modifie l’adresse de retour pour exécuter le code existant avec le contexte qui répond à l’objectif de l’adversaire.

L’ASLR obligatoire force une rebase de toutes les DLL dans le processus. Un développeur peut activer ASLR à l’aide de l’option d’éditeur de liens [/DYNAMICBASE,](https://docs.microsoft.com/cpp/build/reference/dynamicbase-use-address-space-layout-randomization?view=vs-2019&preserve-view=true) et cette atténuation a le même effet.

Lorsque le gestionnaire de mémoire est mappage dans l’image dans le processus, l’ASLR obligatoire rebasera de force les DLLs et les EXE qui n’ont pas choisi d’y rebascier. Notez toutefois que ce rebasing n’a pas d’entropie et peut donc être placé à un emplacement prévisible en mémoire. Pour l’emplacement rebased et aléatoire des binaires, cette atténuation doit être couplée avec des allocations de mémoire [aléatoires (ASLR de](#randomize-memory-allocations-bottom-up-aslr)bas en haut).

### <a name="compatibility-considerations"></a>Considérations sur la compatibilité

Cet impact sur la compatibilité de l’ASLR est généralement limité aux applications plus anciennes qui ont été conçues à l’aide de compilateurs qui ont effectué des hypothèses sur l’adresse de base d’un fichier binaire ou qui ont retiré les informations de déplacement de base. Cela peut entraîner des erreurs imprévisibles lorsque le flux d’exécution tente de passer à l’emplacement attendu, plutôt qu’à l’emplacement réel de la mémoire.

### <a name="configuration-options"></a>Options de configuration

**Ne pas autoriser les images vidées** : cette option bloque le chargement des images dont les informations de déplacement ont été vidées. Le format de fichier Windows PE contient des adresses absolues et le compilateur génère également une [table de déplacement de base que le chargeur peut utiliser pour rechercher toutes les références de mémoire relatives et leur décalage, afin qu’elles soient mises à jour si le fichier binaire ne se charge pas à son adresse de base préférée. Certaines applications plus anciennes ne détaillent pas ces informations dans les builds de production, et par conséquent, ces binaires ne peuvent pas être rebasenés. Cette atténuation bloque le chargement de ces binaires (au lieu de leur permettre de se charger à leur adresse de base préférée).

> [!Note]
> **Forcer la randomisation des images (ASLR obligatoire)** n’a pas de mode audit.

## <a name="import-address-filtering-iaf"></a>Importer le filtrage des adresses (IAF)

### <a name="description"></a>Description

L’atténuation du filtrage des adresses d’importation (IAF) permet d’atténuer le risque qu’un adversaire modifie le flux de contrôle d’une application en modifiant la table d’adresses d’importation (IAT) pour rediriger vers le code arbitraire du choix de l’attaquant lorsque cette fonction est appelée. Un attaquant peut utiliser cette approche pour pirater le contrôle ou intercepter, inspecter et potentiellement bloquer les appels aux API sensibles.

Les pages de mémoire de toutes les API protégées auront la [protection](https://docs.microsoft.com/windows/win32/memory/creating-guard-pages) PAGE_GUARD protection qui leur est appliquée. Lorsqu’une personne tente d’accéder à cette mémoire, elle génère une STATUS_GUARD_PAGE_VIOLATION. L’atténuation gère cette exception et si l’instruction d’accès n’est pas validée, le processus est interrompu.

Cette atténuation protège les API Windows suivantes :

- `GetProcAddress`
- `GetProcAddressForCaller`
- `LoadLibraryA`
- `LoadLibraryExA`
- `LoadLibraryW`
- `LoadLibraryExW`
- `LdrGetProcedureAddress`
- `LdrGetProcedureAddressEx`
- `LdrGetProcedureAddressForCaller`
- `LdrLoadDll`
- `VirtualProtect`
- `VirtualProtectEx`
- `VirtualAlloc`
- `VirtualAllocEx`
- `NtAllocateVirtualMemory`
- `NtProtectVirtualMemory`
- `CreateProcessA`
- `CreateProcessW`
- `WinExec`
- `CreateProcessAsUserA`
- `CreateProcessAsUserW`
- `GetModuleHandleA`
- `GetModuleHandleW`
- `RtlDecodePointer`
- `DecodePointer`

### <a name="compatibility-considerations"></a>Considérations sur la compatibilité

Les applications légitimes qui effectuent une interception d’API peuvent être détectées par cette atténuation et provoquer le crash de certaines applications. Les shims de compatibilité des applications et des logiciels de sécurité en sont des exemples.

### <a name="configuration-options"></a>Options de configuration

**Audit uniquement** : vous pouvez activer cette atténuation en mode audit afin de mesurer l’impact potentiel de la compatibilité sur une application. Les événements d’audit peuvent ensuite être visualisateurs dans l’observateur d’événements ou à l’aide de la recherche avancée [dans Microsoft Defender pour point de terminaison.](https://docs.microsoft.com/microsoft-365/security/defender/advanced-hunting-overview)

## <a name="randomize-memory-allocations-bottom-up-aslr"></a>Randomize memory allocations (Bottom-up ASLR)

### <a name="description"></a>Description

Rendre aléatoires les allocations de mémoire (ASLR de bas en haut) ajoute de l’entropie aux déplacements, de sorte que leur emplacement est aléatoire et donc moins prévisible. Cette atténuation nécessite l’application de la réduction du temps de travail obligatoire.

La taille de l’espace d’adressare 32 bits place des contraintes pratiques sur l’entropie qui peuvent être ajoutées, et par conséquent, les applications 64 bits rendent plus difficile pour un attaquant de deviner un emplacement en mémoire.

### <a name="compatibility-considerations"></a>Considérations sur la compatibilité

La plupart des applications compatibles avec l’ASLR obligatoire (rebasing) sont également compatibles avec l’autre entropie de l’ASLR de bas en haut. Certaines applications peuvent avoir des problèmes de troncation de pointeur si elles sauvegardent des pointeurs locaux dans des variables 32 bits (en attendant une adresse de base inférieure à 4 Go), et seront donc incompatibles avec l’option d’entropie élevée (qui peut être désactivée).

### <a name="configuration-options"></a>Options de configuration

N’utilisez pas **d’entropie** élevée : cette option désactive l’utilisation de l’ASLR haute entropie, qui ajoute 24 bits d’entropie (1 To de variance) dans l’allocation de bas en haut pour les applications 64 bits.

> [!Note]
> **Les allocations de mémoire aléatoires (ASLR de** bas en haut) n’ont pas de mode audit.

## <a name="simulate-execution-simexec"></a>Simuler l’exécution (SimExec)

### <a name="description"></a>Description

La simulation d’exécution (SimExec) est une atténuation pour les applications 32 bits uniquement. Cela permet de vérifier que les appels aux API sensibles retournent aux fonctions d’appelant légitimes. Pour ce faire, il intercepte les appels dans les API sensibles, puis simule l’exécution de ces API en parpant les instructions de langage d’assembly codées à la recherche de l’instruction RET, qui doit revenir à l’appelant. Il inspecte ensuite cette fonction et fait un parcours vers l’arrière en mémoire pour trouver l’instruction CALL précédente afin de déterminer si la fonction et l’instruction CALL correspondent, et que l’instruction RET n’a pas été interceptée.

Les API interceptées par cette atténuation sont :

- `LoadLibraryA`
- `LoadLibraryW`
- `LoadLibraryExA`
- `LoadLibraryExW`
- `LdrLoadDll`
- `VirtualAlloc`
- `VirtualAllocEx`
- `NtAllocateVirtualMemory`
- `VirtualProtect`
- `VirtualProtectEx`
- `NtProtectVirtualMemory`
- `HeapCreate`
- `RtlCreateHeap`
- `CreateProcessA`
- `CreateProcessW`
- `CreateProcessInternalA`
- `CreateProcessInternalW`
- `NtCreateUserProcess`
- `NtCreateProcess`
- `NtCreateProcessEx`
- `CreateRemoteThread`
- `CreateRemoteThreadEx`
- `NtCreateThreadEx`
- `WriteProcessMemory`
- `NtWriteVirtualMemory`
- `WinExec`
- `CreateFileMappingA`
- `CreateFileMappingW`
- `CreateFileMappingNumaW`
- `NtCreateSection`
- `MapViewOfFile`
- `MapViewOfFileEx`
- `MapViewOfFileFromApp`
- `LdrGetProcedureAddressForCaller`

Si un gadget ROP est détecté, le processus est terminé.

### <a name="compatibility-considerations"></a>Considérations sur la compatibilité

Les applications qui effectuent l’interception d’API, en particulier les logiciels de sécurité, peuvent entraîner des problèmes de compatibilité avec cette atténuation.

Cette atténuation est incompatible avec l’atténuation De Code Guard arbitraire.

### <a name="configuration-options"></a>Options de configuration

**Audit uniquement** : vous pouvez activer cette atténuation en mode audit afin de mesurer l’impact potentiel de la compatibilité sur une application. Les événements d’audit peuvent ensuite être visualisateurs dans l’observateur d’événements ou à l’aide de la recherche avancée [dans Microsoft Defender pour point de terminaison.](https://docs.microsoft.com/microsoft-365/security/defender/advanced-hunting-overview)

## <a name="validate-api-invocation-callercheck"></a>Valider l’appel d’API (CallerCheck)

### <a name="description"></a>Description

Valider l’appel d’API (CallerCheck) est une atténuation des techniques de programmation orientée retour (ROP) qui valide que les API sensibles ont été appelées à partir d’un appelant valide. Cette atténuation inspecte l’adresse de l’adresse de retour transmise, puis se désassemble de manière heuristique vers l’arrière pour trouver un appel au-dessus de l’adresse de l’appelant afin de déterminer si la cible de l’appel correspond au paramètre passé dans la fonction.

Les API interceptées par cette atténuation sont :

- `LoadLibraryA`
- `LoadLibraryW`
- `LoadLibraryExA`
- `LoadLibraryExW`
- `LdrLoadDll`
- `VirtualAlloc`
- `VirtualAllocEx`
- `NtAllocateVirtualMemory`
- `VirtualProtect`
- `VirtualProtectEx`
- `NtProtectVirtualMemory`
- `HeapCreate`
- `RtlCreateHeap`
- `CreateProcessA`
- `CreateProcessW`
- `CreateProcessInternalA`
- `CreateProcessInternalW`
- `NtCreateUserProcess`
- `NtCreateProcess`
- `NtCreateProcessEx`
- `CreateRemoteThread`
- `CreateRemoteThreadEx`
- `NtCreateThreadEx`
- `WriteProcessMemory`
- `NtWriteVirtualMemory`
- `WinExec`
- `CreateFileMappingA`
- `CreateFileMappingW`
- `CreateFileMappingNumaW`
- `NtCreateSection`
- `MapViewOfFile`
- `MapViewOfFileEx`
- `MapViewOfFileFromApp`
- `LdrGetProcedureAddressForCaller`

Si un gadget ROP est détecté, le processus est terminé.

### <a name="compatibility-considerations"></a>Considérations sur la compatibilité

Les applications qui effectuent l’interception d’API, en particulier les logiciels de sécurité, peuvent entraîner des problèmes de compatibilité avec cette atténuation.

Cette atténuation est incompatible avec l’atténuation De Code Guard arbitraire.

### <a name="configuration-options"></a>Options de configuration

**Audit uniquement** : vous pouvez activer cette atténuation en mode audit afin de mesurer l’impact potentiel de la compatibilité sur une application. Les événements d’audit peuvent ensuite être visualisateurs dans l’observateur d’événements ou à l’aide de la recherche avancée [dans Microsoft Defender pour point de terminaison.](https://docs.microsoft.com/microsoft-365/security/defender/advanced-hunting-overview)

## <a name="validate-exception-chains-sehop"></a>Valider les chaînes d’exception (SEHOP)

### <a name="description"></a>Description

La validation des chaînes d’exceptions (SEHOP) est une atténuation par rapport à la technique d’exploitation de l’rite *seH (Structured Exception Handler).* [La gestion structurée des exceptions](https://docs.microsoft.com/windows/win32/debug/structured-exception-handling) est le processus par lequel une application peut demander à gérer une exception particulière. Les handlers d’exception sont chaînés ensemble, de sorte que si un seul de ces derniers choisit de ne pas gérer une exception particulière, il peut être transmis au prochain de la chaîne jusqu’à ce qu’il décide de le gérer. Étant donné que la liste du handler est dynamique, elle est stockée sur la pile. Une personne malveillante peut utiliser une vulnérabilité de dépassement de la pile pour ensuite réécrire le handler d’exceptions avec un pointeur vers le code de son choix.

Cette atténuation repose sur la conception de SEH, où chaque entrée SEH contient à la fois un pointeur vers le handler d’exceptions, ainsi qu’un pointeur vers le prochain de la chaîne d’exceptions. Cette atténuation est appelée par le répartiteur d’exceptions, qui valide la chaîne SEH lorsqu’une exception est appelée. Il vérifie que :

- Tous les enregistrements de chaîne d’exceptions se trouve dans les limites de la pile
- Tous les enregistrements d’exception sont alignés
- Aucun pointeur de handler d’exception ne pointe vers la pile
- Il n’existe pas de pointeurs arrière
- La chaîne d’exceptions se termine à un handler d’exception final connu

Si ces validations échouent, la gestion des exceptions est abandonnée et l’exception n’est pas gérée.

### <a name="compatibility-considerations"></a>Considérations sur la compatibilité

Les problèmes de compatibilité avec SEHOP sont relativement rares. Il est rare qu’une application dépende de la corruption de la chaîne d’exceptions. Toutefois, certaines applications sont touchées par les modifications subtiles du minutage, qui peuvent se manifester sous la forme d’une condition de course qui révèle un bogue latent multi-thread dans l’application.

### <a name="configuration-options"></a>Options de configuration

> [!Note]
> **La validation des chaînes d’exceptions (SEHOP)** n’a pas de mode audit.

## <a name="validate-handle-usage"></a>Valider l’utilisation des handles

### <a name="description"></a>Description

*Valider l’utilisation de la* poignée est une prévention qui permet de se protéger contre une attaque à l’aide d’un handle existant pour accéder à un objet protégé. Un [handle](https://docs.microsoft.com/windows/win32/sysinfo/handles-and-objects) est une référence à un objet protégé. Si le code de l’application fait référence à un handle non valide, cela peut indiquer qu’un adversaire tente d’utiliser un handle qu’il a précédemment enregistré (mais dont le comptage des références d’application ne serait pas informé). Si l’application tente d’utiliser un objet non valide, au lieu de renvoyer simplement la valeur null, l’application lève une exception (STATUS_INVALID_HANDLE).

Cette atténuation est appliquée automatiquement aux applications du Windows Store.

### <a name="compatibility-considerations"></a>Considérations sur la compatibilité

Les applications qui ne suivaient pas avec précision les références de handle et qui n’inséraient pas ces opérations dans des gestions d’exceptions seront potentiellement impactées par cette atténuation.

### <a name="configuration-options"></a>Options de configuration

> [!Note]
> **Valider l’utilisation de la poignée** n’a pas de mode audit.

## <a name="validate-heap-integrity"></a>Valider l’intégrité du tas

### <a name="description"></a>Description

La *validation de l’atténuation* de l’intégrité du tas augmente le niveau de protection des atténuations de tas dans Windows, en entraînant la fin de l’application en cas de détection d’une altération du tas. Les atténuations sont les suivantes :

- Empêcher la libération d’un handle HEAP
- Effectuer une autre validation sur les en-têtes de bloc étendus pour les allocations de tas
- Vérification que les allocations de tas ne sont pas déjà marquées comme étant en cours d’utilisation
- Ajout de pages de protection à de grandes allocations, segments de tas et sous-catégories au-dessus d’une taille minimale

### <a name="compatibility-considerations"></a>Considérations sur la compatibilité

Cette atténuation est déjà appliquée par défaut pour les applications 64 bits et les applications 32 bits ciblant Windows Vista ou une édition ultérieure. Les applications héritées de Windows XP ou antérieures sont les plus à risque, bien que les problèmes de compatibilité soient rares.

### <a name="configuration-options"></a>Options de configuration

> [!Note]
> **Vérifier que l’intégrité du tas** n’a pas de mode audit.

## <a name="validate-image-dependency-integrity"></a>Valider l’intégrité des dépendances d’image

### <a name="description"></a>Description

La *validation de l’atténuation des dépendances d’image* permet de se protéger contre les attaques qui tentent de substituer du code aux DLL liées statiquement par les binaires Windows. La technique de la DLL contre les abus du mécanisme de recherche du chargeur pour injecter du code malveillant, qui peut être utilisé pour obtenir du code malveillant s’exécutant dans un contexte élevé. Lorsque le chargeur charge un fichier binaire signé Windows, puis charge toutes les DLL dont dépend le binaire, ces binaires sont vérifiés pour s’assurer qu’ils sont également signés numériquement en tant que fichier binaire Windows. En cas d’échec de la vérification de la signature, la DLL n’est pas chargée et une exception est lancée, ce qui retourne l’état STATUS_INVALID_IMAGE_HASH.

### <a name="compatibility-considerations"></a>Considérations sur la compatibilité

Les problèmes de compatibilité sont rares. Les applications qui dépendent du remplacement des binaires Windows par des versions privées locales seront impactées, et il existe également un petit risque de révéler des bogues de minutage discrets dans les applications multi-threads.

### <a name="configuration-options"></a>Options de configuration

**Audit uniquement** : vous pouvez activer cette atténuation en mode audit afin de mesurer l’impact potentiel de la compatibilité sur une application. Les événements d’audit peuvent ensuite être visualisateurs dans l’observateur d’événements ou à l’aide de la recherche avancée [dans Microsoft Defender pour point de terminaison.](https://docs.microsoft.com/microsoft-365/security/defender/advanced-hunting-overview)

## <a name="validate-stack-integrity-stackpivot"></a>Valider l’intégrité de la pile (StackPivot)

### <a name="description"></a>Description

L’atténuation valider l’intégrité de la pile *(StackPivot)* permet de se protéger contre les attaques du tableau croisé dynamique de pile, une attaque ROP dans laquelle une personne malveillante crée une pile factice dans la mémoire du tas, puis astuces de l’application pour retourner dans la pile factice qui contrôle le flux d’exécution.

Cette atténuation intercepte de nombreuses API Windows et inspecte la valeur du pointeur de pile. Si l’adresse du pointeur de pile ne se trouve pas entre le bas et le haut de la pile, un événement est enregistré et, s’il n’est pas en mode audit, le processus est interrompu.

Les API interceptées par cette atténuation sont :

- `LoadLibraryA`
- `LoadLibraryW`
- `LoadLibraryExA`
- `LoadLibraryExW`
- `LdrLoadDll`
- `VirtualAlloc`
- `VirtualAllocEx`
- `NtAllocateVirtualMemory`
- `VirtualProtect`
- `VirtualProtectEx`
- `NtProtectVirtualMemory`
- `HeapCreate`
- `RtlCreateHeap`
- `CreateProcessA`
- `CreateProcessW`
- `CreateProcessInternalA`
- `CreateProcessInternalW`
- `NtCreateUserProcess`
- `NtCreateProcess`
- `NtCreateProcessEx`
- `CreateRemoteThread`
- `CreateRemoteThreadEx`
- `NtCreateThreadEx`
- `WriteProcessMemory`
- `NtWriteVirtualMemory`
- `WinExec`
- `CreateFileMappingA`
- `CreateFileMappingW`
- `CreateFileMappingNumaW`
- `NtCreateSection`
- `MapViewOfFile`
- `MapViewOfFileEx`
- `MapViewOfFileFromApp`
- `LdrGetProcedureAddressForCaller`

### <a name="compatibility-considerations"></a>Considérations sur la compatibilité

Les applications qui utilisent des piles factices seront impactées, et il existe également un petit risque de révéler des bogues de minutage discrets dans les applications multi-threads.
Les applications qui effectuent l’interception d’API, en particulier les logiciels de sécurité, peuvent entraîner des problèmes de compatibilité avec cette atténuation.

Cette atténuation est incompatible avec l’atténuation De Code Guard arbitraire.

### <a name="configuration-options"></a>Options de configuration

**Audit uniquement** : vous pouvez activer cette atténuation en mode audit afin de mesurer l’impact potentiel de la compatibilité sur une application. Les événements d’audit peuvent ensuite être visualisateurs dans l’observateur d’événements ou à l’aide de la recherche avancée [dans Microsoft Defender pour point de terminaison.](https://docs.microsoft.com/microsoft-365/security/defender/advanced-hunting-overview)
