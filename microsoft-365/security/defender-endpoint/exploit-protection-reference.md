---
title: Référence de protection contre les codes malveillants exploitant une faille de sécurité
keywords: atténuations, vulnérabilités, vulnérabilité, atténuation, code malveillant exploitant une faille de sécurité, codes malveillants exploitant une faille de sécurité, emet
description: Détails sur le fonctionnement de la fonctionnalité de protection contre l’exploitation dans Windows
ms.pagetype: security
ms.service: microsoft-365-security
ms.mktglfcycl: manage
ms.sitesec: library
ms.localizationpriority: medium
audience: ITPro
author: denisebmsft
ms.author: deniseb
ms.reviewer: cjacks
manager: dansimp
ms.custom: asr
ms.subservice: mde
ms.topic: article
ms.collection: m365-security-compliance
ms.date: 10/19/2021
search.appverid: met150
ms.openlocfilehash: e04644d23e9fd4ebc0adcf1d7cb2eb8f18f537d1
ms.sourcegitcommit: 9b133379196da2b3a4bb311b07ff274f43780f68
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 09/14/2022
ms.locfileid: "67695382"
---
# <a name="exploit-protection-reference"></a>Référence d’Exploit Protection

[!INCLUDE [Microsoft 365 Defender rebranding](../../includes/microsoft-defender.md)]


**S’applique à :**
- [Microsoft Defender pour point de terminaison Plan 2](https://go.microsoft.com/fwlink/?linkid=2154037)
- [Microsoft 365 Defender](https://go.microsoft.com/fwlink/?linkid=2118804)

> Vous voulez découvrir Microsoft Defender pour point de terminaison ? [Inscrivez-vous pour bénéficier d’un essai gratuit.](https://signup.microsoft.com/create-account/signup?products=7f379fee-c4f9-4278-b0a1-e4c8c2fcdf7e&ru=https://aka.ms/MDEp2OpenTrial?ocid=docs-wdatp-enablesiem-abovefoldlink)

Exploit Protection fournit des protections avancées pour les applications que le professionnel de l’informatique peut appliquer une fois que le développeur a compilé et distribué le logiciel.

Cet article vous aide à comprendre le fonctionnement d’Exploit Protection, à la fois au niveau de la stratégie et au niveau de l’atténuation individuelle, pour vous aider à créer et à appliquer des stratégies Exploit Protection.

## <a name="how-mitigations-are-applied"></a>Comment les atténuations sont appliquées

Les mesures d'atténuation Exploit Protection sont appliquées par application.

Les mesures d'atténuation sont configurées via une entrée de Registre pour chaque programme pour lequel vous configurez des protections. Ces paramètres sont stockés dans l’entrée de Registre **MitigationOptions** pour chaque programme (**HKEY_LOCAL_MACHINE \ SOFTWARE \ Microsoft \ Windows NT \ CurrentVersion \ Image File Execution Options \ *ImageFileName* \ MitigationOptions**). Ils prennent effet lorsque vous redémarrez le programme et restent effectifs jusqu'à ce que vous les modifiiez et redémarriez à nouveau le programme.

> [!IMPORTANT]
> Les options d’exécution de fichier image vous permettent uniquement de spécifier un nom de fichier ou un chemin d’accès, et non un numéro de version, une architecture ou tout autre élément de différenciation. Veillez à cibler les mesures d'atténuation pour les applications qui ont des noms ou des chemins d'accès uniques, en les appliquant uniquement sur les appareils sur lesquels vous avez testé cette version et cette architecture de l'application.

Si vous configurez les mesures d'atténuation Exploit Protection à l'aide d'un fichier de configuration XML, soit via PowerShell, la stratégie de groupe ou MDM, lors du traitement de ce fichier de configuration XML, des paramètres de registre individuels seront configurés pour vous.

Lorsque la stratégie de distribution du fichier XML n’est plus appliquée, les paramètres déployés par ce fichier de configuration XML ne sont pas automatiquement supprimés. Pour supprimer les paramètres Exploit Protection, exportez la configuration XML à partir d'un appareil Windows 10 ou Windows 11 propre, puis déployez ce nouveau fichier XML. Par ailleurs, Microsoft fournit un fichier XML dans le cadre des lignes de base de la sécurité de Windows pour réinitialiser les paramètres Exploit Protection.

Pour réinitialiser les paramètres Exploit Protection à l’aide de PowerShell, vous pouvez utiliser la commande suivante :

```powershell
Set-ProcessMitigation -PolicyFilePath EP-reset.xml
```
Voici le fichier EP-reset.xml distribué avec les bases de référence de sécurité de Windows :
```xml
<?xml version="1.0" encoding="UTF-8"?>
<MitigationPolicy>
  <AppConfig Executable="ONEDRIVE.EXE">
    <DEP OverrideDEP="false" />
    <ASLR OverrideRelocateImages="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
    <ImageLoad OverrideBlockRemoteImages="false" />
  </AppConfig>
  <AppConfig Executable="firefox.exe">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
  </AppConfig>
  <AppConfig Executable="fltldr.exe">
    <DEP OverrideDEP="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
    <ImageLoad OverrideBlockRemoteImages="false" />
    <ChildProcess OverrideChildProcess="false" />
  </AppConfig>
  <AppConfig Executable="GROOVE.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
    <ImageLoad OverrideBlockRemoteImages="false" />
    <ChildProcess OverrideChildProcess="false" />
  </AppConfig>
  <AppConfig Executable="Acrobat.exe">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="AcroRd32.exe">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="chrome.exe">
    <DEP OverrideDEP="false" />
  </AppConfig>
  <AppConfig Executable="EXCEL.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="iexplore.exe">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="INFOPATH.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="java.exe">
    <DEP OverrideDEP="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="javaw.exe">
    <DEP OverrideDEP="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="javaws.exe">
    <DEP OverrideDEP="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="LYNC.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="MSACCESS.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="MSPUB.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="OIS.EXE">
    <DEP OverrideDEP="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="OUTLOOK.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="plugin-container.exe">
    <DEP OverrideDEP="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="POWERPNT.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="PPTVIEW.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="VISIO.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="VPREVIEW.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="WINWORD.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="wmplayer.exe">
    <DEP OverrideDEP="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="wordpad.exe">
    <DEP OverrideDEP="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
</MitigationPolicy>
```

## <a name="mitigation-reference"></a>Informations de référence sur l’atténuation

Les sections suivantes détaillent les protections fournies par chaque atténuation Exploit Protection, les considérations de compatibilité pour l'atténuation et les options de configuration disponibles.

## <a name="arbitrary-code-guard"></a>Protection du code arbitraire

### <a name="description"></a>Description

La protection contre le code arbitraire permet de se protéger contre un attaquant malveillant qui charge le code de son choix dans la mémoire par le biais d'une vulnérabilité de sécurité de la mémoire et qui est en mesure d'exécuter ce code.

La protection contre le code arbitraire protège une application contre l'exécution de code généré dynamiquement (code qui n'est pas chargé, par exemple, à partir de l'exe lui-même ou d'une dll). La protection de code arbitraire fonctionne en empêchant la mémoire d’être marquée comme exécutable. Lorsqu’une application tente d’[allouer de la mémoire](/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc), nous vérifions les indicateurs de protection. (La mémoire peut être allouée avec des indicateurs de protection de lecture, d’écriture et/ou d’exécution.) Si l’allocation tente d’inclure l’indicateur de protection [*d’exécution*](/windows/win32/memory/memory-protection-constants), l’allocation de mémoire échoue et retourne un code d’erreur (STATUS_DYNAMIC_CODE_BLOCKED). De même, si une application tente de [modifier les indicateurs de protection de la mémoire](/windows/win32/api/memoryapi/nf-memoryapi-virtualprotect) qui a déjà été alloué et inclut l’indicateur de protection [*d’exécution*](/windows/win32/memory/memory-protection-constants), le changement d’autorisation échoue et retourne un code d’erreur (STATUS_DYNAMIC_CODE_BLOCKED).

En empêchant la définition de l’indicateur *d’exécution*, la fonctionnalité de prévention de l’exécution des données de Windows 10 et Windows 11 peut ensuite se protéger contre le pointeur d’instruction défini sur cette mémoire et exécutant ce code.

### <a name="compatibility-considerations"></a>Considérations en matière de compatibilité

La protection de code arbitraire empêche l’allocation de mémoire en tant qu’exécutable, ce qui présente un problème de compatibilité avec des approches telles que les compilateurs juste-à-temps (JIT). La plupart des navigateurs modernes, par exemple, compilent JavaScript en code natif afin d'optimiser les performances. Pour prendre en charge cette atténuation, ils doivent être réarchitecturés pour déplacer la compilation JIT en dehors du processus protégé. D'autres applications dont la conception génère dynamiquement du code à partir de scripts ou d'autres langages intermédiaires seront également incompatibles avec cette atténuation.

### <a name="configuration-options"></a>Options de configuration

**Autoriser le refus de thread** : vous pouvez configurer l’atténuation pour permettre à un thread individuel de refuser cette protection. Le développeur doit avoir écrit l’application avec connaissance de cette atténuation et avoir appelé l’API [**SetThreadInformation**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-setthreadinformation) avec le paramètre *ThreadInformation* défini sur **ThreadDynamicCodePolicy** afin d’être autorisé à exécuter du code dynamique sur ce thread.

**Auditer uniquement** : vous pouvez activer cette atténuation en mode audit afin de mesurer l’impact potentiel sur la compatibilité d’une application. Les événements d’audit peuvent ensuite être affichés dans l’observateur d’événements ou à l’aide du repérage avancé dans [Defender pour point de terminaison](/microsoft-365/security/defender/advanced-hunting-overview).

## <a name="block-low-integrity-images"></a>Bloquer les images de faible intégrité

### <a name="description"></a>Description

Le blocage des images à faible intégrité empêche l'application de charger des fichiers qui ne sont pas fiables, généralement parce qu'ils ont été téléchargés d'Internet à partir d'un navigateur en mode bac à sable.

Cette mesure d'atténuation bloque les chargements d'images si l'image possède une entrée de contrôle d'accès (ACE) qui accorde l'accès aux processus Low IL et qui n'a pas d'approbation de confiance ACE. Il est implémenté par le gestionnaire de mémoire, ce qui empêche le mappage du fichier en mémoire. Si une application tente de mapper une image à faible intégrité, elle déclenche une erreur STATUS_ACCESS_DENIED. Pour plus d’informations sur le fonctionnement des niveaux d’intégrité, consultez [Contrôle d'intégrité par mandat](/windows/win32/secauthz/mandatory-integrity-control).

### <a name="compatibility-considerations"></a>Considérations en matière de compatibilité

Le blocage des images à faible intégrité empêche l'application de charger les fichiers téléchargés sur Internet. Si le flux de travail de votre application nécessite le chargement d'images téléchargées, vous devrez vous assurer qu'elles sont téléchargées à partir d'un processus plus fiable ou qu'elles sont explicitement réétiquetées pour appliquer cette mesure d'atténuation.

### <a name="configuration-options"></a>Options de configuration

**Auditer uniquement** : vous pouvez activer cette atténuation en mode audit afin de mesurer l’impact potentiel sur la compatibilité d’une application. Les événements d’audit peuvent ensuite être affichés dans l’observateur d’événements ou à l’aide du repérage avancé dans [Microsoft Defender pour point de terminaison](/microsoft-365/security/defender/advanced-hunting-overview).

## <a name="block-remote-images"></a>Bloquer les images distantes

### <a name="description"></a>Description

Le blocage d’images distantes permet d’empêcher l’application de charger des fichiers hébergés sur un appareil distant, tel qu’un partage UNC. Le blocage d’images distantes permet de se protéger contre le chargement de fichiers binaires en mémoire sur un appareil externe contrôlé par l’attaquant.

Cette mesure d'atténuation bloquera les chargements d'images s'il est déterminé que l'image se trouve sur un appareil distant. Il est implémenté par le gestionnaire de mémoire, ce qui empêche le mappage du fichier en mémoire. Si une application tente de mapper un fichier distant, elle déclenche une erreur de STATUS_ACCESS_DENIED.

### <a name="compatibility-considerations"></a>Considérations en matière de compatibilité

Bloquer les images distantes empêche l’application de charger des images à partir d’appareils distants. Si votre application charge des fichiers ou des plug-ins à partir d’appareils distants, elle ne sera pas compatible avec cette atténuation.

### <a name="configuration-options"></a>Options de configuration

**Auditer uniquement** : vous pouvez activer cette atténuation en mode audit afin de mesurer l’impact potentiel sur la compatibilité d’une application. Les événements d’audit peuvent ensuite être affichés dans l’observateur d’événements ou à l’aide du repérage avancé dans [Microsoft Defender pour point de terminaison](/microsoft-365/security/defender/advanced-hunting-overview).

## <a name="block-untrusted-fonts"></a>Bloquer les polices non approuvées

### <a name="description"></a>Description

Le blocage des polices non fiables atténue le risque qu'une faille dans l'analyse des polices permette à l'attaquant d'exécuter du code sur l'appareil. Seules les polices installées dans le répertoire windows\fonts sont chargées pour traitement par GDI.

Cette mesure d'atténuation est implémentée dans la GDI, qui valide l'emplacement du fichier. Si le fichier ne se trouve pas dans le répertoire des polices du système, la police ne sera pas chargée pour l'analyse et l'appel échouera.

Cette mesure d'atténuation s'ajoute à la mesure d'atténuation intégrée fournie dans Windows 10 1607 et versions ultérieures, et Windows 11, qui déplace l'analyse des polices hors du noyau et dans un conteneur d'applications en mode utilisateur. Par conséquent, tout exploit basé sur l'analyse des polices se produit dans un contexte isolé et en bac à sable, ce qui réduit considérablement le risque. Pour plus d’informations sur cette atténuation, consultez le blog [Renforcement de Windows 10 grâce aux atténuations des exploits de type vulnérabilité zero-day](https://www.microsoft.com/security/blog/2017/01/13/hardening-windows-10-with-zero-day-exploit-mitigations/).

### <a name="compatibility-considerations"></a>Considérations en matière de compatibilité

L’utilisation la plus courante des polices en dehors du répertoire des polices système est celle des [polices web](/typography/fonts/font-faq#web). Les navigateurs modernes, tels que Microsoft Edge, utilisent DirectWrite au lieu de GDI et ne sont pas affectés. Toutefois, les navigateurs hérités, tels que Internet Explorer 11 (et le mode Internet Explorer dans le nouveau Microsoft Edge) peuvent être affectés, en particulier avec les applications telles qu’Office 365, qui utilisent des glyphes de police pour afficher l’interface utilisateur.

### <a name="configuration-options"></a>Options de configuration

**Auditer uniquement** : vous pouvez activer cette atténuation en mode audit afin de mesurer l’impact potentiel sur la compatibilité d’une application. Les événements d’audit peuvent ensuite être affichés dans l’observateur d’événements ou à l’aide du repérage avancé dans [Microsoft Defender pour point de terminaison](/microsoft-365/security/defender/advanced-hunting-overview).

## <a name="code-integrity-guard"></a>Protection de l’intégrité du code

### <a name="description"></a>Description

La protection de l’intégrité du code garantit que tous les fichiers binaires chargés dans un processus sont signés numériquement par Microsoft. Protection de l’intégrité du code inclut des signatures [WHQL](/windows-hardware/drivers/install/whql-release-signature) (Microsoft Windows Hardware Quality Labs), qui permettent aux pilotes approuvés par WHQL de s’exécuter dans le processus.

Cette atténuation est implémentée dans le gestionnaire de mémoire, ce qui empêche le binaire d’être mappé en mémoire. Si vous tentez de charger un fichier binaire qui n’est pas signé par Microsoft, le gestionnaire de mémoire renvoie l’erreur STATUS_INVALID_IMAGE_HASH. En bloquant au niveau du gestionnaire de mémoire, cela empêche les fichiers binaires chargés par le processus et les fichiers binaires injectés dans le processus.

### <a name="compatibility-considerations"></a>Considérations en matière de compatibilité

Cette atténuation bloque spécifiquement tout fichier binaire qui n’est pas signé par Microsoft. Par conséquent, il sera incompatible avec la plupart des logiciels tiers, sauf si ce logiciel est distribué par (et signé numériquement par) Microsoft Store, et si l'option permettant le chargement d'images signées par Microsoft Store est sélectionnée.

### <a name="configuration-options"></a>Options de configuration

**Autorisez également le chargement des images signées par Microsoft Store** – les applications distribuées par le Microsoft Store seront signées numériquement par le Microsoft Store, et l’ajout de cette configuration permettra le chargement par l’application des fichiers binaires qui ont suivi le processus de certification du magasin.

**Auditer uniquement** : vous pouvez activer cette atténuation en mode audit afin de mesurer l’impact potentiel sur la compatibilité d’une application. Les événements d’audit peuvent ensuite être affichés dans l’observateur d’événements ou à l’aide du repérage avancé dans [Microsoft Defender pour point de terminaison](/microsoft-365/security/defender/advanced-hunting-overview).

## <a name="control-flow-guard-cfg"></a>Protection du flux de contrôle (CFG)

### <a name="description"></a>Description

CFG (Control Flow Guard) atténue le risque d’attaques utilisant des vulnérabilités d’altération de la mémoire en protégeant les appels de fonction indirects. Par exemple, un attaquant peut utiliser une vulnérabilité de type dépassement de mémoire tampon pour écraser la mémoire contenant un pointeur de fonction, et remplacer ce pointeur de fonction par un pointeur vers un code exécutable de son choix (qui peut également avoir été injecté dans le programme).

Cette atténuation est fournie par l’injection d’une autre vérification au moment de la compilation. Avant chaque appel de fonction indirecte, d’autres instructions sont ajoutées, qui vérifient que la cible est une cible d’appel valide avant d’être appelée. Si la cible n’est pas une cible d’appel valide, l’application est arrêtée. Par conséquent, seules les applications compilées avec prise en charge CFG peuvent bénéficier de cette atténuation.

La vérification d’une cible valide est fournie par le noyau Windows. Lorsque des fichiers exécutables sont chargés, les métadonnées des cibles d’appel indirects sont extraites au moment du chargement et marquées comme cibles d’appel valides. En outre, lorsque la mémoire est allouée et marquée comme exécutable (par exemple pour le code généré), ces emplacements de mémoire sont également marqués comme cibles d’appel valides, pour prendre en charge des mécanismes tels que la compilation JIT.

### <a name="compatibility-considerations"></a>Considérations en matière de compatibilité

Dans la mesure où les applications doivent être compilées pour prendre en charge CFG, elles déclarent implicitement leur compatibilité avec celle-ci. Par conséquent, la plupart des applications doivent fonctionner avec cette atténuation activée. Étant donné que ces vérifications sont compilées dans le fichier binaire, la configuration que vous pouvez appliquer consiste simplement à désactiver les vérifications dans le noyau Windows. En d’autres termes, l’atténuation est activée par défaut, mais vous pouvez configurer le noyau Windows pour qu’il retourne toujours « oui » si vous déterminez ultérieurement qu’il existe un problème de compatibilité que le développeur d’applications n’a pas détecté dans ses tests, ce qui devrait être rare.

### <a name="configuration-options"></a>Options de configuration

**Utiliser une CFG stricte** – En mode strict, tous les fichiers binaires chargés dans le processus doivent être compilés pour Flux de contrôle Guard (ou n’avoir aucun code exécutable dans ces derniers, par exemple des DLL de ressource) pour pouvoir être chargés.

> [!Note]
> **La protection de flux de contrôle** n’a pas de mode d’audit. Les fichiers binaires sont compilés avec cette atténuation activée.

## <a name="data-execution-prevention-dep"></a>Prévention de l’exécution des données (PED)

### <a name="description"></a>Description

La prévention de l’exécution des données empêche l’exécution de la mémoire qui n’a pas été allouée explicitement en tant qu’exécutable. DEP permet de se protéger contre un attaquant qui injecte du code malveillant dans le processus, par exemple via un dépassement de mémoire tampon, puis exécute ce code.

Si vous tentez de définir le pointeur d’instruction sur une adresse mémoire non marquée comme exécutable, le processeur lève une exception (violation de protection générale), ce qui provoque le blocage de l’application.

### <a name="compatibility-considerations"></a>Considérations en matière de compatibilité

Tous les exécutables x64, ARM et ARM-64 sont activés par défaut et ne peuvent pas être désactivés. Dans la mesure où une application n’aura jamais été exécutée sans DEP, la compatibilité est supposée.

Tous les fichiers binaires x86 (32 bits) ont DEP activé par défaut, mais DEP peut être désactivé par processus. Certaines anciennes applications héritées, généralement développées avant Windows XP SP2, peuvent ne pas être compatibles avec DEP. Ces applications génèrent généralement du code dynamiquement (par exemple, la compilation JIT) ou un lien vers des bibliothèques plus anciennes (telles que des versions antérieures d’ATL) qui génèrent dynamiquement du code.

### <a name="configuration-options"></a>Options de configuration

**Activer l’émulation AtL Thunk** – Cette option de configuration désactive l’émulation ATL Thunk. ATL, la bibliothèque de modèles ActiveX, est conçu pour être aussi petit et rapide que possible. Pour réduire la taille binaire, elle utilise une technique appelée *thunking*. Le thunking est généralement considéré pour interagir entre les applications 32 bits et 16 bits, mais il n’y a pas de composants 16 bits dans ATL ici. Au lieu de cela, afin d’optimiser la taille du fichier binaire, ATL stocke le code machine en mémoire qui n’est pas aligné sur le mot (en créant un fichier binaire plus petit), puis appelle directement ce code. Les composants ATL compilés avec Visual Studio 7.1 ou une version antérieure (Visual Studio 2003) n’allouent pas cette mémoire en tant qu’exécutable . L’émulation thunk résout ce problème de compatibilité. Les applications qui ont un modèle d’extension binaire (par exemple, Internet Explorer 11) doivent souvent avoir l’émulation Thunk ATL activée.

## <a name="disable-extension-points"></a>Désactiver les points d’extension

### <a name="description"></a>Description

Cette atténuation désactive différents points d’extension pour une application, qui peuvent être utilisés pour établir la persistance ou élever des privilèges de contenu malveillant.

Cela inclut les opérations suivantes :

- **DLL AppInit** : chaque fois qu’un processus démarre, le système charge la bibliothèque de liens dynamiques spécifiée dans le contexte du processus nouvellement démarré avant d’appeler sa fonction de point d’entrée. [Vous trouverez ici des détails sur les DLL AppInit](/windows/win32/winmsg/about-window-classes#application-global-classes). Une fois cette atténuation appliquée, les DLL AppInit ne sont pas chargées. À compter de Windows 7, les DLL AppInit doivent être signées numériquement, [comme décrit ici](/windows/win32/win7appqual/appinit-dlls-in-windows-7-and-windows-server-2008-r2). En outre, à compter de Windows 8, les DLL AppInit ne seront pas chargées si SecureBoot est activé, [comme décrit ici](/windows/win32/dlls/secure-boot-and-appinit-dlls).
- **EIM héritées** – Un éditeur de méthode d’entrée (IME) permet à un utilisateur de taper du texte dans une langue qui comporte plus de caractères que ce qui peut être représenté sur un clavier. Des tiers sont en mesure de créer des IDE. Un IME malveillant pourrait obtenir des informations d'identification ou d'autres informations sensibles à partir de cette capture d'entrée. Certaines IDE, appelées IDE héritées, fonctionnent uniquement sur les applications de bureau Windows et non sur les applications UWP. Cette atténuation empêchera également ce fichier IME hérité de se charger dans l’application de bureau Windows spécifiée.
- **Crochets d’événements Windows** – une application peut appeler [l’API SetWinEventHook](/windows/win32/api/winuser/nf-winuser-setwineventhook) pour inscrire son intérêt dans un événement en cours. Une bibliothèque de liens dynamiques est spécifiée et peut être injectée dans le processus. Cette atténuation force la publication du crochet dans le processus d’inscription au lieu d’exécuter in-process via une DLL injectée.

### <a name="compatibility-considerations"></a>Considérations en matière de compatibilité

La plupart de ces points d'extension sont relativement peu utilisés, de sorte que l'impact de la compatibilité est généralement faible, en particulier au niveau d'une application individuelle. La seule considération est si les utilisateurs utilisent des IDE héritées tierces qui ne fonctionnent pas avec l’application protégée.

### <a name="configuration-options"></a>Options de configuration

Il n’existe aucune option de configuration pour cette atténuation.

> [!Note]
> **La désactivation des points d’extension** n’a pas de mode d’audit.

## <a name="disable-win32k-system-calls"></a>Désactiver les appels système Win32k

### <a name="description"></a>Description

Win32k.sys fournit une grande surface d’attaque pour un attaquant. En tant que composant en mode noyau, il est fréquemment ciblé en tant que vecteur d'évasion pour les applications qui sont protégées par un bac à sable. Cette atténuation empêche les appels à win32k.sys en bloquant un thread qui se convertit en un thread GUI, qui a ensuite accès aux fonctions Win32k. Un thread n’est pas une interface graphique utilisateur lors de sa création, mais converti lors du premier appel à win32k.sys, ou via un appel d’API à [IsGuiThread](/windows/win32/api/winuser/nf-winuser-isguithread).

### <a name="compatibility-considerations"></a>Considérations en matière de compatibilité

Cette atténuation est conçue pour les processus qui sont des processus dédiés qui ne sont pas des processus d’interface utilisateur. Par exemple, de nombreux navigateurs modernes utilisent l'isolation des processus et intègrent des processus non IU. Toute application qui affiche une interface graphique à l'aide d'un seul processus est affectée par cette atténuation.

### <a name="configuration-options"></a>Options de configuration

**Auditer uniquement** : vous pouvez activer cette atténuation en mode audit afin de mesurer l’impact potentiel sur la compatibilité d’une application. Les événements d’audit peuvent ensuite être affichés dans l’observateur d’événements ou à l’aide du repérage avancé dans [Microsoft Defender pour point de terminaison](/microsoft-365/security/defender/advanced-hunting-overview).

## <a name="do-not-allow-child-processes"></a>Ne pas autoriser les processus enfants

### <a name="description"></a>Description

Cette atténuation empêche une application de créer de nouvelles applications enfants. Une technique couramment utilisée par les adversaires consiste à lancer un processus de confiance sur l'appareil à l'aide d'une entrée malveillante (une attaque de type « living off the land »), ce qui nécessite souvent de lancer une autre application sur l'appareil. S’il n’existe aucune raison légitime pour laquelle une application lance un processus enfant, cette atténuation atténue ce vecteur d’attaque potentiel. L'atténuation est appliquée en définissant une propriété sur le jeton de processus, qui bloque la création d'un jeton pour le processus enfant avec le message d'erreur STATUS_CHILD_PROCESS_BLOCKED.

### <a name="compatibility-considerations"></a>Considérations en matière de compatibilité

Si votre application lance des applications enfant pour une raison quelconque, comme la prise en charge d'hyperliens qui lancent un navigateur ou un navigateur externe, ou qui lancent d'autres utilitaires sur l'ordinateur, cette fonctionnalité sera rompue avec l'application de cette atténuation.

### <a name="configuration-options"></a>Options de configuration

**Auditer uniquement** : vous pouvez activer cette atténuation en mode audit afin de mesurer l’impact potentiel sur la compatibilité d’une application. Les événements d’audit peuvent ensuite être affichés dans l’observateur d’événements ou à l’aide du repérage avancé dans [Microsoft Defender pour point de terminaison](/microsoft-365/security/defender/advanced-hunting-overview).

## <a name="export-address-filtering"></a>Exporter le filtrage d’adresses

### <a name="description"></a>Description

Le filtrage des adresses d’exportation (EAF) réduit le risque de code malveillant en examinant la table d’adresses d’exportation de tous les modules chargés pour rechercher les modules qui contiennent des API utiles pour leur attaque. Il s’agit d’une tactique courante utilisée par shellcode. Afin d'atténuer le risque d'une telle attaque, cette atténuation protège trois modules couramment attaqués :

- ntdll.dll
- kernelbase.dll
- kernel32.dll

L’atténuation protège la page mémoire dans le répertoire d’exportation qui pointe vers la [table d’adresses d’exportation](/windows/win32/debug/pe-format#export-address-table). Cette page mémoire se verra appliquer la protection [PAGE_GUARD](/windows/win32/memory/creating-guard-pages). Lorsqu’une personne tente d’accéder à cette mémoire, elle génère une STATUS_GUARD_PAGE_VIOLATION. L’atténuation gère cette exception et, si l’instruction d’accès ne réussit pas la validation, le processus est arrêté.

### <a name="compatibility-considerations"></a>Considérations en matière de compatibilité

Cette atténuation est principalement un problème pour les applications telles que les débogueurs, les applications bac à sable, les applications utilisant DRM ou les applications qui implémentent la technologie anti-débogage.

### <a name="configuration-options"></a>Options de configuration

**Valider l’accès aux modules couramment exploités** – Cette option, également appelée EAF+, ajoute des protections pour d’autres modules fréquemment attaqués :

- `mshtml.dll`
- `flash*.ocx`
- `jscript*.ocx`
- `vbscript.dll`
- `vgx.dll`
- `mozjs.dll`
- `xul.dll`
- `acrord32.dll`
- `acrofx32.dll`
- `acroform.api`

En outre, en activant EAF+, cette atténuation ajoute la protection PAGE_GUARD à la page contenant l’en-tête « MZ », les deux premiers octets de [l’en-tête DOS dans un fichier PE](/windows/win32/debug/pe-format#ms-dos-stub-image-only), qui est un autre aspect du contenu de mémoire connu que shellcode peut rechercher pour identifier les modules susceptibles d’intéresser la mémoire.

**Auditer uniquement** : vous pouvez activer cette atténuation en mode audit afin de mesurer l’impact potentiel sur la compatibilité d’une application. Les événements d’audit peuvent ensuite être affichés dans l’observateur d’événements ou à l’aide du repérage avancé dans [Microsoft Defender pour point de terminaison](/microsoft-365/security/defender/advanced-hunting-overview).

## <a name="force-randomization-for-images-mandatory-aslr"></a>Forcer la randomisation des images (randomisation du format d’espace d’adresse obligatoire)

### <a name="description"></a>Description

La randomisation de la disposition de l’espace d’adressage (ASLR) réduit le risque qu’un attaquant utilise sa connaissance de la disposition de la mémoire du système afin d’exécuter du code déjà présent dans la mémoire du processus et déjà marqué comme exécutable. Cela peut atténuer le risque qu’un attaquant utilise des techniques telles que les attaques de type « retour à libc », où l’adversaire définit le contexte, puis modifie l’adresse de retour pour exécuter du code existant avec le contexte qui correspond à l’objectif de l’adversaire.

L'ASLR obligatoire force un rebasement de toutes les DLL dans le processus. Un développeur peut activer ASLR à l’aide de l’option d’éditeur de liens [/DYNAMICBASE](/cpp/build/reference/dynamicbase-use-address-space-layout-randomization), et cette atténuation a le même effet.

Lorsque le gestionnaire de mémoire effectue un mappage dans l’image dans le processus, l’ASLR obligatoire rebase de force les DLL et les EXE qui n’ont pas choisi ASLR. Notez toutefois que ce rebasement n'a pas d'entropie, et peut donc être placé à un emplacement prévisible en mémoire. Pour un emplacement rebasé et aléatoire des binaires, cette atténuation doit être associée à[Allocations de mémoire aléatoires (randomisation du format d’espace d’adresse de bas en haut)](#randomize-memory-allocations-bottom-up-aslr).

### <a name="compatibility-considerations"></a>Considérations en matière de compatibilité

Cet impact sur la compatibilité d’ASLR est généralement limité aux anciennes applications créées à l’aide de compilateurs qui ont fait des hypothèses sur l’adresse de base d’un fichier binaire ou qui ont supprimé les informations de réadressage de base. Cela peut entraîner des erreurs imprévisibles, car le flux d’exécution tente de passer à l’emplacement attendu, plutôt qu’à l’emplacement réel, en mémoire.

### <a name="configuration-options"></a>Options de configuration

**Ne pas autoriser les images supprimées** – Cette option bloque le chargement des images dont les informations de réadressage ont été supprimées. Le format de fichier Windows PE contient des adresses absolues, et le compilateur génère également une [table de réadressage de base que le chargeur peut utiliser pour rechercher toutes les références de mémoire relative et leur décalage, afin qu’elles puissent être mises à jour si le binaire ne se charge pas à son adresse de base préférée. Certaines applications plus anciennes suppriment ces informations dans les builds de production et, par conséquent, ces fichiers binaires ne peuvent pas être rebasés. Cette atténuation empêche le chargement de ces fichiers binaires (au lieu de les autoriser à se charger à leur adresse de base préférée).

> [!Note]
> **Forcer la randomisation des images (randomisation du format d’espace d’adresse obligatoire)** n’a pas de mode d’audit.

## <a name="import-address-filtering-iaf"></a>Importer le filtrage d’adresses (IAF)

### <a name="description"></a>Description

L’atténuation du filtrage des adresses d’importation (IAF) permet d’atténuer le risque qu’un adversaire modifie le flux de contrôle d’une application en modifiant la table d’adresses d’importation (IAT) pour rediriger vers le code arbitraire du choix de l’attaquant quand cette fonction est appelée. Un attaquant pourrait utiliser cette approche pour pirater le contrôle, ou pour intercepter, inspecter et potentiellement bloquer les appels à des API sensibles.

La protection [PAGE_GUARD](/windows/win32/memory/creating-guard-pages) est appliquée aux pages mémoire de toutes les API protégées. Lorsqu’une personne tente d’accéder à cette mémoire, elle génère une STATUS_GUARD_PAGE_VIOLATION. L’atténuation gère cette exception et, si l’instruction d’accès ne réussit pas la validation, le processus est arrêté.

Cette atténuation protège les API Windows suivantes :

- `GetProcAddress`
- `GetProcAddressForCaller`
- `LoadLibraryA`
- `LoadLibraryExA`
- `LoadLibraryW`
- `LoadLibraryExW`
- `LdrGetProcedureAddress`
- `LdrGetProcedureAddressEx`
- `LdrGetProcedureAddressForCaller`
- `LdrLoadDll`
- `VirtualProtect`
- `VirtualProtectEx`
- `VirtualAlloc`
- `VirtualAllocEx`
- `NtAllocateVirtualMemory`
- `NtProtectVirtualMemory`
- `CreateProcessA`
- `CreateProcessW`
- `WinExec`
- `CreateProcessAsUserA`
- `CreateProcessAsUserW`
- `GetModuleHandleA`
- `GetModuleHandleW`
- `RtlDecodePointer`
- `DecodePointer`

### <a name="compatibility-considerations"></a>Considérations en matière de compatibilité

Les applications légitimes qui effectuent l’interception d’API peuvent être détectées par cette atténuation et provoquer le blocage de certaines applications. Les logiciels de sécurité et les shims de compatibilité des applications en sont des exemples.

### <a name="configuration-options"></a>Options de configuration

**Auditer uniquement** : vous pouvez activer cette atténuation en mode audit afin de mesurer l’impact potentiel sur la compatibilité d’une application. Les événements d’audit peuvent ensuite être affichés dans l’observateur d’événements ou à l’aide du repérage avancé dans [Microsoft Defender pour point de terminaison](/microsoft-365/security/defender/advanced-hunting-overview).

## <a name="randomize-memory-allocations-bottom-up-aslr"></a>Allocations de mémoire aléatoires (randomisation du format d’espace d’adresse de bas en haut)

### <a name="description"></a>Description

Allocations de mémoire aléatoires (randomisation du format d’espace d’adresse de bas en haut) ajoutent une entropie aux réadressages, de sorte que leur emplacement est aléatoire et donc moins prévisible. Cette atténuation nécessite la prise en compte de l’ASLR obligatoire.

La taille de l'espace d'adressage 32 bits impose des contraintes pratiques sur l'entropie qui peut être ajoutée. Par conséquent, les applications 64 bits rendent plus difficile pour un attaquant de deviner un emplacement dans la mémoire.

### <a name="compatibility-considerations"></a>Considérations en matière de compatibilité

La plupart des applications compatibles avec l'ASLR obligatoire (rebasement) sont également compatibles avec l'autre entropie de l'ASLR ascendant. Certaines applications peuvent rencontrer des problèmes de troncature de pointeur si elles sauvegardent des pointeurs locaux dans des variables 32 bits (s'attendant à une adresse de base inférieure à 4 Go), et seront donc incompatibles avec l'option d'entropie élevée (qui peut être désactivée).

### <a name="configuration-options"></a>Options de configuration

**N’utilisez pas l’entropie élevée** – Cette option désactive l’utilisation d’ASLR à entropie élevée, qui ajoute 24 bits d’entropie (1 To de variance) à l’allocation inférieure pour les applications 64 bits.

> [!Note]
> **Allocations de mémoire aléatoires (randomisation du format d’espace d’adresse de bas en haut)** n’ont pas de mode d’audit.

## <a name="simulate-execution-simexec"></a>Simuler l’exécution (SimExec)

### <a name="description"></a>Description

Simulez l’exécution (SimExec) est une atténuation pour les applications 32 bits uniquement. Cela permet de vérifier que les appels aux API sensibles retournent aux fonctions d’appelant légitimes. Pour ce faire, il intercepte les appels à des API sensibles, puis simule l'exécution de ces API en parcourant les instructions codées en langage d'assemblage à la recherche de l'instruction RET, qui doit retourner à l'appelant. Il inspecte ensuite cette fonction et remonte dans la mémoire pour trouver l'instruction CALL précédente afin de déterminer si la fonction et l'instruction CALL correspondent, et si la RET n'a pas été interceptée.

Les API interceptées par cette atténuation sont les suivantes :

- `LoadLibraryA`
- `LoadLibraryW`
- `LoadLibraryExA`
- `LoadLibraryExW`
- `LdrLoadDll`
- `VirtualAlloc`
- `VirtualAllocEx`
- `NtAllocateVirtualMemory`
- `VirtualProtect`
- `VirtualProtectEx`
- `NtProtectVirtualMemory`
- `HeapCreate`
- `RtlCreateHeap`
- `CreateProcessA`
- `CreateProcessW`
- `CreateProcessInternalA`
- `CreateProcessInternalW`
- `NtCreateUserProcess`
- `NtCreateProcess`
- `NtCreateProcessEx`
- `CreateRemoteThread`
- `CreateRemoteThreadEx`
- `NtCreateThreadEx`
- `WriteProcessMemory`
- `NtWriteVirtualMemory`
- `WinExec`
- `CreateFileMappingA`
- `CreateFileMappingW`
- `CreateFileMappingNumaW`
- `NtCreateSection`
- `MapViewOfFile`
- `MapViewOfFileEx`
- `MapViewOfFileFromApp`
- `LdrGetProcedureAddressForCaller`

Si un gadget ROP est détecté, le processus est interrompu.

### <a name="compatibility-considerations"></a>Considérations en matière de compatibilité

Les applications qui effectuent l’interception d’API, en particulier les logiciels de sécurité, peuvent entraîner des problèmes de compatibilité avec cette atténuation.

Cette atténuation n’est pas compatible avec l’atténuation arbitraire de Code Guard.

### <a name="configuration-options"></a>Options de configuration

**Auditer uniquement** : vous pouvez activer cette atténuation en mode audit afin de mesurer l’impact potentiel sur la compatibilité d’une application. Les événements d’audit peuvent ensuite être affichés dans l’observateur d’événements ou à l’aide du repérage avancé dans [Microsoft Defender pour point de terminaison](/microsoft-365/security/defender/advanced-hunting-overview).

## <a name="validate-api-invocation-callercheck"></a>Valider l’invocation de l’API (CallerCheck)

### <a name="description"></a>Description

Validate API invocation (CallerCheck) est une mesure d'atténuation pour les techniques de programmation orientée retour (ROP) qui valide que les API sensibles ont été appelées par un appelant valide. Cette atténuation inspecte l’adresse de retour passée, puis désassemble de façon heuristique vers l’arrière pour rechercher un appel au-dessus de l’adresse de retour afin de déterminer si la cible d’appel correspond au paramètre passé dans la fonction.

Les API interceptées par cette atténuation sont les suivantes :

- `LoadLibraryA`
- `LoadLibraryW`
- `LoadLibraryExA`
- `LoadLibraryExW`
- `LdrLoadDll`
- `VirtualAlloc`
- `VirtualAllocEx`
- `NtAllocateVirtualMemory`
- `VirtualProtect`
- `VirtualProtectEx`
- `NtProtectVirtualMemory`
- `HeapCreate`
- `RtlCreateHeap`
- `CreateProcessA`
- `CreateProcessW`
- `CreateProcessInternalA`
- `CreateProcessInternalW`
- `NtCreateUserProcess`
- `NtCreateProcess`
- `NtCreateProcessEx`
- `CreateRemoteThread`
- `CreateRemoteThreadEx`
- `NtCreateThreadEx`
- `WriteProcessMemory`
- `NtWriteVirtualMemory`
- `WinExec`
- `CreateFileMappingA`
- `CreateFileMappingW`
- `CreateFileMappingNumaW`
- `NtCreateSection`
- `MapViewOfFile`
- `MapViewOfFileEx`
- `MapViewOfFileFromApp`
- `LdrGetProcedureAddressForCaller`

Si un gadget ROP est détecté, le processus est interrompu.

### <a name="compatibility-considerations"></a>Considérations en matière de compatibilité

Les applications qui effectuent l’interception d’API, en particulier les logiciels de sécurité, peuvent entraîner des problèmes de compatibilité avec cette atténuation.

Cette atténuation n’est pas compatible avec l’atténuation arbitraire de Code Guard.

### <a name="configuration-options"></a>Options de configuration

**Auditer uniquement** : vous pouvez activer cette atténuation en mode audit afin de mesurer l’impact potentiel sur la compatibilité d’une application. Les événements d’audit peuvent ensuite être affichés dans l’observateur d’événements ou à l’aide du repérage avancé dans [Microsoft Defender pour point de terminaison](/microsoft-365/security/defender/advanced-hunting-overview).

## <a name="validate-exception-chains-sehop"></a>Valider les chaînes d’exception (SEHOP)

### <a name="description"></a>Description

La validation des chaînes d’exception (SEHOP) est une atténuation contre la technique d’exploitation de *remplacement SEH (Structured Exception Handler).* [La gestion structurée des exceptions](/windows/win32/debug/structured-exception-handling) est le processus par lequel une application peut demander à gérer une exception particulière. Les gestionnaires d’exceptions sont chaînés, de sorte que si un gestionnaire d’exceptions choisit de ne pas gérer une exception particulière, il peut être transmis au gestionnaire d’exceptions suivant dans la chaîne jusqu’à ce qu’il décide de le gérer. Étant donné que la liste du gestionnaire est dynamique, elle est stockée sur la pile. Un attaquant peut utiliser une vulnérabilité de dépassement de capacité de la pile pour remplacer ensuite le gestionnaire d’exceptions par un pointeur vers le code du choix de l’attaquant.

Cette atténuation s’appuie sur la conception de SEH, où chaque entrée SEH contient à la fois un pointeur vers le gestionnaire d’exceptions, ainsi qu’un pointeur vers le gestionnaire suivant dans la chaîne d’exceptions. Cette atténuation est appelée par le distributeur d'exceptions, qui valide la chaîne SEH lorsqu'une exception est appelée. Il vérifie que :

- Tous les enregistrements de chaîne d’exception se trouvent dans les limites de la pile
- Tous les enregistrements d’exception sont alignés
- Aucun pointeur de gestionnaire d’exceptions ne pointe vers la pile
- Il n’existe aucun pointeur vers l’arrière
- La chaîne d’exceptions se termine à un gestionnaire d’exceptions final connu

Si ces validations échouent, la gestion des exceptions est abandonnée et l’exception n’est pas gérée.

### <a name="compatibility-considerations"></a>Considérations en matière de compatibilité

Les problèmes de compatibilité avec SEHOP sont relativement rares. Il est rare qu’une application dépende de l’endommagement de la chaîne d’exceptions. Toutefois, certaines applications sont affectées par les modifications subtiles du minutage, qui peuvent se manifestent sous la forme d’une condition de concurrence qui révèle un bogue multithreading latent dans l’application.

### <a name="configuration-options"></a>Options de configuration

> [!Note]
> **La validation des chaînes d’exception (SEHOP)** n’a pas de mode d’audit.

## <a name="validate-handle-usage"></a>Valider l’utilisation de la poignée

### <a name="description"></a>Description

*Valider l’utilisation d’une poignée* est une atténuation qui permet de se protéger contre un attaquant à l’aide d’une poignée existante pour accéder à un objet protégé. Une [poignée](/windows/win32/sysinfo/handles-and-objects) est une référence à un objet protégé. Si le code d’application fait référence à une poignée non valide, cela peut indiquer qu’un adversaire tente d’utiliser une poignée qu’il a enregistré précédemment (mais dont le comptage des références d’application ne serait pas pris en compte). Si l’application tente d’utiliser un objet non valide, au lieu de retourner simplement null, l’application lève une exception (STATUS_INVALID_HANDLE).

Cette atténuation est automatiquement appliquée aux applications du Windows Store.

### <a name="compatibility-considerations"></a>Considérations en matière de compatibilité

Les applications qui n’ont pas suivi avec précision les références de poignée et qui n’enveloppaient pas ces opérations dans des gestionnaires d’exceptions seront potentiellement affectées par cette atténuation.

### <a name="configuration-options"></a>Options de configuration

> [!Note]
> **La validation de l’utilisation de la poignée** n’a pas de mode d’audit.

## <a name="validate-heap-integrity"></a>Valider l’intégrité du segment de mémoire

### <a name="description"></a>Description

L'atténuation *Valider l’intégrité du segment de mémoire* augmente le niveau de protection des atténuations du segment de mémoire dans Windows, en provoquant la fin de l'application si une corruption du segment de mémoire est détectée. Les atténuations sont les suivantes :

- Empêcher la libération d'un handle HEAP
- Exécution d'une autre validation sur les en-têtes de blocs étendus pour les allocations du segment de mémoire.
- Vérification que les allocations du segment de mémoire ne sont pas déjà marquées comme étant en cours d’utilisation
- Ajout de pages de garde à de grandes allocations, segments du segment de mémoire et sous-ensembles au-dessus d’une taille minimale

### <a name="compatibility-considerations"></a>Considérations en matière de compatibilité

Cette atténuation est déjà appliquée par défaut pour les applications 64 bits et pour les applications 32 bits ciblant Windows Vista ou version ultérieure. Les applications héritées de Windows XP ou d’une version antérieure sont les plus à risque, bien que les problèmes de compatibilité soient rares.

### <a name="configuration-options"></a>Options de configuration

> [!Note]
> **Vérifiez que l’intégrité du segment de mémoire** n’a pas de mode d’audit.

## <a name="validate-image-dependency-integrity"></a>Valider l’intégrité des dépendances d’image

### <a name="description"></a>Description

L’atténuation *valider dépendances d’image* permet de se protéger contre les attaques qui tentent de remplacer le code par des DLL liées statiquement par des fichiers binaires Windows. La technique de la DLL abuse du mécanisme de recherche du chargeur pour injecter du code malveillant, qui peut être utilisé pour exécuter du code malveillant dans un contexte élevé. Lorsque le chargeur charge un binaire signé Windows, puis charge les DLL dont le binaire dépend, ces binaires sont vérifiés pour s'assurer qu'ils sont également signés numériquement en tant que fichier binaire Windows. En cas d’échec de la vérification de signature, la DLL n’est pas chargée et lève une exception, renvoyant l’état de STATUS_INVALID_IMAGE_HASH.

### <a name="compatibility-considerations"></a>Considérations en matière de compatibilité

Les problèmes de compatibilité sont rares. Les applications qui dépendent du remplacement des fichiers binaires Windows par des versions privées locales seront affectées, et il existe également un faible risque de révéler de subtils bogues de synchronisation dans les applications multithreads.

### <a name="configuration-options"></a>Options de configuration

**Auditer uniquement** : vous pouvez activer cette atténuation en mode audit afin de mesurer l’impact potentiel sur la compatibilité d’une application. Les événements d’audit peuvent ensuite être affichés dans l’observateur d’événements ou à l’aide du repérage avancé dans [Microsoft Defender pour point de terminaison](/microsoft-365/security/defender/advanced-hunting-overview).

## <a name="validate-stack-integrity-stackpivot"></a>Valider l’intégrité de la pile (StackPivot)

### <a name="description"></a>Description

L’atténuation *valider l’intégrité de la pile (StackPivot)* permet de se protéger contre l’attaque Stack Pivot, une attaque ROP dans laquelle un attaquant crée une pile factice dans la mémoire du tas, puis insère l’application dans la pile factice qui contrôle le flux d’exécution.

Cette atténuation intercepte de nombreuses API Windows et inspecte la valeur du pointeur de pile. Si l’adresse du pointeur de pile ne se situe pas entre le bas et le haut de la pile, un événement est enregistré et, s’il n’est pas en mode audit, le processus est arrêté.

Les API interceptées par cette atténuation sont les suivantes :

- `LoadLibraryA`
- `LoadLibraryW`
- `LoadLibraryExA`
- `LoadLibraryExW`
- `LdrLoadDll`
- `VirtualAlloc`
- `VirtualAllocEx`
- `NtAllocateVirtualMemory`
- `VirtualProtect`
- `VirtualProtectEx`
- `NtProtectVirtualMemory`
- `HeapCreate`
- `RtlCreateHeap`
- `CreateProcessA`
- `CreateProcessW`
- `CreateProcessInternalA`
- `CreateProcessInternalW`
- `NtCreateUserProcess`
- `NtCreateProcess`
- `NtCreateProcessEx`
- `CreateRemoteThread`
- `CreateRemoteThreadEx`
- `NtCreateThreadEx`
- `WriteProcessMemory`
- `NtWriteVirtualMemory`
- `WinExec`
- `CreateFileMappingA`
- `CreateFileMappingW`
- `CreateFileMappingNumaW`
- `NtCreateSection`
- `MapViewOfFile`
- `MapViewOfFileEx`
- `MapViewOfFileFromApp`
- `LdrGetProcedureAddressForCaller`

### <a name="compatibility-considerations"></a>Considérations en matière de compatibilité

Les applications qui utilisent des piles factices seront affectées, et il existe également un petit risque de révéler des bogues de minutage subtiles dans les applications multithreads.
Les applications qui effectuent l’interception d’API, en particulier les logiciels de sécurité, peuvent entraîner des problèmes de compatibilité avec cette atténuation.

Cette atténuation n’est pas compatible avec l’atténuation arbitraire de Code Guard.

### <a name="configuration-options"></a>Options de configuration

**Auditer uniquement** : vous pouvez activer cette atténuation en mode audit afin de mesurer l’impact potentiel sur la compatibilité d’une application. Les événements d’audit peuvent ensuite être affichés dans l’observateur d’événements ou à l’aide du repérage avancé dans [Microsoft Defender pour point de terminaison](/microsoft-365/security/defender/advanced-hunting-overview).
